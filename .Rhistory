knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/Solvej/Desktop/results/")
library(jsonlite)
library(psychTestR)
library(tidyverse)
library(ggplot2)
library(glue)
library(data.table)
# library(Rcpp)
library(lme4)
library(readxl)
library(tidyr)
# setting the results-folder as the root directory
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/Solvej/Desktop/results/")
## reading all the data files and creating one cleaned-up dataframe ##
# getting a list of all the relevant files
diag_name = "*.rds"
diag_files = list.files(pattern = diag_name, recursive = TRUE)
# creating a tibble
c <-  tibble()
for (name in diag_files) {
a1 <- as.data.frame(readRDS(name))
# parsing all the experimental data
b1 <- parse_json(a1$results.test)
c1 <- rbindlist(lapply(b1, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE) %>% mutate(ID=substr(name, start=1, stop=nchar(name)-4))
# parsing the response to the gender q
b2 <- parse_json(a1$results.gender)
c2 <- rbindlist(lapply(b2, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
# adding gender to the actual data
c1$gender <- str_trim(c2$response)
# parsing the response to the age and edu qs
b3 <- parse_json(a1$results.demographics)
c3 <- rbindlist(lapply(b3, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
# adding age to the actual data
c1$age <- as.numeric(gsub("[^0-9.,-]", "", c3$response[1])) # gsub is for removing if people added "år" to their age
# adding edu to the actual data
c1$edu <- c3$response[2]
# parsing the response to the native langauge q
b4 <- parse_json(a1$results.nativelang)
c4 <- rbindlist(lapply(b4, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
c1$nat <- c4$response
# adding it *all* together over multipler runs...
c = bind_rows(c, c1)
for (row in length(c$response)) {
c$response[row]
}
}
# col_id = match(c("rt", "response", "math", "answer", "condition", "trial_type", "trial_index", "time_elapsed", "ID"), colnames(c))
col_id = match(c("rt", "response", "math", "answer","sentence", "condition", "trial_type", "trial_index", "time_elapsed", "ID", "gender", "age", "edu", "nat"), colnames(c))
d = c[, col_id]
# unnesting the response-column
d$response <- unlist(d$response)
# making an index for every second response starting with the first - corresponding to all the math-responses
idx <- seq(1,length(d$response),2)
# creating a column full of NAs cuz for the correct-column we'll only be filling up half of them (namely those with math-responses)
d$correct <- NA
# comparing all the math-responses with the corect math-answers
d$correct[idx] <- d$response[idx]==d$answer[idx]
d$correct[idx+1] <- d$response[idx]==d$answer[idx]
# overview of d
# summary(d)
# taking out the responses based on incorrect math responses
d_clean <- d[d$correct,]
# summary(d_clean)
clean_idx <- seq(1,length(d_clean$response),2)
# to see a long list of all the written responses (every second response starting from the second response)
# d$response[idx+1]
# d_clean$response[clean_idx+1]
# to see a long list of all the correct/incorrect math-responses
# d$response[idx]==d$answer[idx]
# d_clean$response[idx]==d_clean$answer[idx]
View(d_clean)
# setting the results-folder as the root directory
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/Solvej/Desktop/results_1/")
# loading libraries
library(jsonlite)
library(psychTestR)
library(tidyverse)
library(ggplot2)
library(glue)
library(data.table)
library(lme4)
library(readxl)
library(tidyr)
## reading all the data files and creating one cleaned-up dataframe ##
# getting a list of all the relevant files
diag_name = "*.rds"
diag_files = list.files(pattern = diag_name, recursive = TRUE)
# creating a tibble
c <-  tibble()
for (name in diag_files) {
a1 <- as.data.frame(readRDS(name))
# parsing all the experimental data
b1 <- parse_json(a1$results.test)
c1 <- rbindlist(lapply(b1, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE) %>% mutate(ID=substr(name, start=1, stop=nchar(name)-4))
# parsing the response to the gender q
b2 <- parse_json(a1$results.gender)
c2 <- rbindlist(lapply(b2, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
# adding gender to the actual data
c1$gender <- str_trim(c2$response)
# parsing the response to the age and edu qs
b3 <- parse_json(a1$results.demographics)
c3 <- rbindlist(lapply(b3, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
# adding age to the actual data
c1$age <- as.numeric(gsub("[^0-9.,-]", "", c3$response[1])) # gsub is for removing if people added "år" to their age
# adding edu to the actual data
c1$edu <- c3$response[2]
# parsing the response to the native langauge q
b4 <- parse_json(a1$results.nativelang)
c4 <- rbindlist(lapply(b4, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
c1$nat <- c4$response
# adding it *all* together over multiple runs...
c = bind_rows(c, c1)
for (row in length(c$response)) {
c$response[row]
}
}
# col_id = match(c("rt", "response", "math", "answer", "condition", "trial_type", "trial_index", "time_elapsed", "ID"), colnames(c))
col_id = match(c("rt", "response", "math", "answer","sentence", "condition", "trial_type", "trial_index", "time_elapsed", "ID", "gender", "age", "edu", "nat"), colnames(c))
d = c[, col_id]
# setting the results-folder as the root directory
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/Solvej/Desktop/results/")
## reading all the data files and creating one cleaned-up dataframe ##
# getting a list of all the relevant files
diag_name = "*.rds"
diag_files = list.files(pattern = diag_name, recursive = TRUE)
# creating a tibble
c <-  tibble()
for (name in diag_files) {
a1 <- as.data.frame(readRDS(name))
# parsing all the experimental data
b1 <- parse_json(a1$results.test)
c1 <- rbindlist(lapply(b1, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE) %>% mutate(ID=substr(name, start=1, stop=nchar(name)-4))
# parsing the response to the gender q
b2 <- parse_json(a1$results.gender)
c2 <- rbindlist(lapply(b2, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
# adding gender to the actual data
c1$gender <- str_trim(c2$response)
# parsing the response to the age and edu qs
b3 <- parse_json(a1$results.demographics)
c3 <- rbindlist(lapply(b3, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
# adding age to the actual data
c1$age <- as.numeric(gsub("[^0-9.,-]", "", c3$response[1])) # gsub is for removing if people added "år" to their age
# adding edu to the actual data
c1$edu <- c3$response[2]
# parsing the response to the native langauge q
b4 <- parse_json(a1$results.nativelang)
c4 <- rbindlist(lapply(b4, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
c1$nat <- c4$response
# adding it *all* together over multiple runs...
c = bind_rows(c, c1)
for (row in length(c$response)) {
c$response[row]
}
}
# col_id = match(c("rt", "response", "math", "answer", "condition", "trial_type", "trial_index", "time_elapsed", "ID"), colnames(c))
col_id = match(c("rt", "response", "math", "answer","sentence", "condition", "trial_type", "trial_index", "time_elapsed", "ID", "gender", "age", "edu", "nat"), colnames(c))
d = c[, col_id]
# unnesting the response-column
d$response <- unlist(d$response)
# making an index for every second response starting with the first - corresponding to all the math-responses
idx <- seq(1,length(d$response),2)
# creating a column full of NAs because for the correct-column we'll only be filling up half of them (namely those with math-responses)
d$correct <- NA
# comparing all the math-responses with the corect math-answers
d$correct[idx] <- d$response[idx]==d$answer[idx]
d$correct[idx+1] <- d$response[idx]==d$answer[idx]
# overview of d
# summary(d)
# taking out the responses based on incorrect math responses
d_clean <- d[d$correct,]
# summary(d_clean)
clean_idx <- seq(1,length(d_clean$response),2)
# to see a long list of all the written responses (every second response starting from the second response)
# d$response[idx+1]
# d_clean$response[clean_idx+1]
# to see a long list of all the correct/incorrect math-responses
# d$response[idx]==d$answer[idx]
# d_clean$response[idx]==d_clean$answer[idx]
View(d_clean)
# setting the results-folder as the root directory
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/Solvej/Desktop/results_1/")
# getting a list of all the relevant files
diag_name = "*.rds"
diag_files = list.files(pattern = diag_name, recursive = TRUE)
# creating a tibble
c <-  tibble()
for (name in diag_files) {
a1 <- as.data.frame(readRDS(name))
# parsing all the experimental data
b1 <- parse_json(a1$results.test)
c1 <- rbindlist(lapply(b1, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE) %>% mutate(ID=substr(name, start=1, stop=nchar(name)-4))
# parsing the response to the gender q
b2 <- parse_json(a1$results.gender)
c2 <- rbindlist(lapply(b2, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
# adding gender to the actual data
c1$gender <- str_trim(c2$response)
# parsing the response to the age and edu qs
b3 <- parse_json(a1$results.demographics)
c3 <- rbindlist(lapply(b3, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
# adding age to the actual data
c1$age <- as.numeric(gsub("[^0-9.,-]", "", c3$response[1])) # gsub is for removing if people added "år" to their age
# adding edu to the actual data
c1$edu <- c3$response[2]
# parsing the response to the native langauge q
b4 <- parse_json(a1$results.nativelang)
c4 <- rbindlist(lapply(b4, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
c1$nat <- c4$response
# adding it *all* together over multiple runs...
c = bind_rows(c, c1)
for (row in length(c$response)) {
c$response[row]
}
}
# col_id = match(c("rt", "response", "math", "answer", "condition", "trial_type", "trial_index", "time_elapsed", "ID"), colnames(c))
col_id = match(c("rt", "response", "math", "answer","sentence", "condition", "trial_type", "trial_index", "time_elapsed", "ID", "gender", "age", "edu", "nat"), colnames(c))
d = c[, col_id]
# unnesting the response-column
d$response <- unlist(d$response)
# making an index for every second response starting with the first - corresponding to all the math-responses
idx <- seq(1,length(d$response),2)
# creating a column full of NAs because for the correct-column we'll only be filling up half of them (namely those with math-responses)
d$correct <- NA
# comparing all the math-responses with the corect math-answers
d$correct[idx] <- d$response[idx]==d$answer[idx]
d$correct[idx+1] <- d$response[idx]==d$answer[idx]
# taking out the responses based on incorrect math responses
d_clean <- d[d$correct,]
clean_idx <- seq(1,length(d_clean$response),2)
View(d_clean)
# setting the results-folder as the root directory
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/Solvej/Desktop/results_1/")
# loading libraries
library(jsonlite)
library(psychTestR)
library(tidyverse)
library(ggplot2)
library(glue)
library(data.table)
library(lme4)
library(readxl)
library(tidyr)
## reading all the data files and creating one cleaned-up dataframe ##
# getting a list of all the relevant files
diag_name = "*.rds"
diag_files = list.files(pattern = diag_name, recursive = TRUE)
# creating a tibble
c <-  tibble()
for (name in diag_files) {
a1 <- as.data.frame(readRDS(name))
# parsing all the experimental data
b1 <- parse_json(a1$results.test)
c1 <- rbindlist(lapply(b1, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE) %>% mutate(ID=substr(name, start=1, stop=nchar(name)-4))
# parsing the response to the gender question
b2 <- parse_json(a1$results.gender)
c2 <- rbindlist(lapply(b2, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
# adding gender to the actual data
c1$gender <- str_trim(c2$response)
# parsing the response to the age and education questions
b3 <- parse_json(a1$results.demographics)
c3 <- rbindlist(lapply(b3, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
# adding age to the actual data
c1$age <- as.numeric(gsub("[^0-9.,-]", "", c3$response[1])) # gsub is for removing if people added "år" to their age
# adding edu to the actual data
c1$edu <- c3$response[2]
# parsing the response to the native langauge question
b4 <- parse_json(a1$results.nativelang)
c4 <- rbindlist(lapply(b4, function(x) if(is.null(x)) data.frame(rt = NA, response = NA) else x), fill = TRUE)
c1$nat <- c4$response
# adding it *all* together over multiple runs...
c = bind_rows(c, c1)
for (row in length(c$response)) {
c$response[row]
}
}
# setting column names
col_id = match(c("rt", "response", "math", "answer","sentence", "condition", "trial_type", "trial_index", "time_elapsed", "ID", "gender", "age", "edu", "nat"), colnames(c))
d = c[, col_id]
# unnesting the response-column
d$response <- unlist(d$response)
# making an index for every second response starting with the first - corresponding to all the math-responses
idx <- seq(1,length(d$response),2)
# creating a column full of NAs because for the correct-column we'll only be filling up half of them (namely those with math-responses)
d$correct <- NA
# comparing all the math-responses with the correct math-answers
d$correct[idx] <- d$response[idx]==d$answer[idx]
d$correct[idx+1] <- d$response[idx]==d$answer[idx]
# taking out the responses based on incorrect math responses
d_clean <- d[d$correct,]
# printing d_clean
d_clean
View(d_clean)
